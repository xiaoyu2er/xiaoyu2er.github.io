[{"title":"44个 Javascript 变态题解析 (上)","date":"2016-06-05T16:00:00.000Z","path":"2016/06/06/44-js-puzzles-part1/","text":"原题来自: javascript-puzzlers 读者可以先去做一下感受感受. 当初笔者的成绩是 21/44… 当初笔者做这套题的时候不仅怀疑智商, 连人生都开始怀疑了…. 不过, 对于基础知识的理解是深入编程的前提. 让我们一起来看看这些变态题到底变态不变态吧! 第1题1[\"1\", \"2\", \"3\"].map(parseInt) 知识点: Array/map Number/parseInt 首先, map接受两个参数, 一个回调函数 callback, 一个回调函数的this值 其中回调函数接受三个参数 currentValue, index, arrary; 而题目中, map只传入了回调函数–parseInt. 其次, parseInt 只接受两个两个参数 string, radix(基数). radix的合法区间是2-36. 默认是10. 所以本题即问 123parseInt('1', 0);parseInt('2', 1);parseInt('3', 2); 首先后两者参数不合法. 第一个笔者猜测0和不传一样被认为是10. 所以答案是 [1, NaN, NaN] 第2题1[typeof null, null instanceof Object] 两个知识点: Operators/typeof Operators/instanceof Operators/instanceof(中) typeof 返回一个表示类型的字符串. instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上. 这个题可以直接看链接… 因为 typeof null === &#39;object&#39; 自语言之初就是这样…. typeof 的结果请看下表: 12345678910type resultUndefined \"undefined\"Null \"object\"Boolean \"boolean\"Number \"number\"String \"string\"Symbol \"symbol\"Host object Implementation-dependentFunction \"function\"Object \"object\" 所以答案 [object, false] 第3题1[ [3,2,1].reduce(Math.pow), [].reduce(Math.pow) ] 知识点: Array/Reduce arr.reduce(callback[, initialValue]) reduce接受两个参数, 一个回调, 一个初始值. 回调函数接受四个参数 previousValue, currentValue, currentIndex, array 需要注意的是 If the array is empty and no initialValue was provided, TypeError would be thrown. 所以第二个表达式会报异常. 第一个表达式等价于 Math.pow(3, 2) =&gt; 9; Math.pow(9, 1) =&gt;9 答案 an error 第4题12var val = 'smtg';console.log('Value is ' + (val === 'smtg') ? 'Something' : 'Nothing'); 两个知识点: Operators/Operator_Precedence Operators/Conditional_Operator 简而言之 + 的优先级 大于 ? 所以原题等价于 &#39;Value is true&#39; ? &#39;Somthing&#39; : &#39;Nonthing&#39; 而不是 &#39;Value is&#39; + (true ? &#39;Something&#39; : &#39;Nonthing&#39;) 答案 &#39;Value is Something&#39; 第5题123456789var name = 'World!';(function () &#123; if (typeof name === 'undefined') &#123; var name = 'Jack'; console.log('Goodbye ' + name); &#125; else &#123; console.log('Hello ' + name); &#125;&#125;)(); 这个相对简单, 一个知识点: Hoisting 在 JavaScript中， functions 和 variables 会被提升。变量提升是JavaScript将声明移至作用域 scope (全局域或者当前函数作用域) 顶部的行为。 这个题目相当于 12345678910var name = 'World!';(function () &#123; var name; if (typeof name === 'undefined') &#123; name = 'Jack'; console.log('Goodbye ' + name); &#125; else &#123; console.log('Hello ' + name); &#125;&#125;)(); 所以答案是 &#39;Goodbye Jack&#39; 第6题1234567var END = Math.pow(2, 53);var START = END - 100;var count = 0;for (var i = START; i &lt;= END; i++) &#123; count++;&#125;console.log(count); 一个知识点: Infinity 在 JS 里, Math.pow(2, 53) == 9007199254740992 是可以表示的最大值. 最大值加一还是最大值. 所以循环不会停. 第7题123var ary = [0,1,2];ary[10] = 10;ary.filter(function(x) &#123; return x === undefined;&#125;); 答案是 [] 看一篇文章理解稀疏数组 译 JavaScript中的稀疏数组与密集数组 Array/filter 我们来看一下 Array.prototype.filter 的 polyfill: 12345678910111213141516171819202122232425262728if (!Array.prototype.filter) &#123; Array.prototype.filter = function(fun/*, thisArg*/) &#123; 'use strict'; if (this === void 0 || this === null) &#123; throw new TypeError(); &#125; var t = Object(this); var len = t.length &gt;&gt;&gt; 0; if (typeof fun !== 'function') &#123; throw new TypeError(); &#125; var res = []; var thisArg = arguments.length &gt;= 2 ? arguments[1] : void 0; for (var i = 0; i &lt; len; i++) &#123; if (i in t) &#123; // 注意这里!!! var val = t[i]; if (fun.call(thisArg, val, i, t)) &#123; res.push(val); &#125; &#125; &#125; return res; &#125;;&#125; 我们看到在迭代这个数组的时候, 首先检查了这个索引值是不是数组的一个属性, 那么我们测试一下. 1230 in ary; =&gt; true3 in ary; =&gt; false10 in ary; =&gt; true 也就是说 从 3 - 9 都是没有初始化的’坑’!, 这些索引并不存在与数组中. 在 array 的函数调用的时候是会跳过这些’坑’的. 第8题12345var two = 0.2var one = 0.1var eight = 0.8var six = 0.6[two - one == one, eight - six == two] JavaScript的设计缺陷?浮点运算：0.1 + 0.2 != 0.3 IEEE 754标准中的浮点数并不能精确地表达小数 那什么时候精准, 什么时候不经准呢? 笔者也不知道… 答案 [true, false] 第9题12345678910111213141516function showCase(value) &#123; switch(value) &#123; case 'A': console.log('Case A'); break; case 'B': console.log('Case B'); break; case undefined: console.log('undefined'); break; default: console.log('Do not know!'); &#125;&#125;showCase(new String('A')); 两个知识点: Statements/switch String switch 是严格比较, String 实例和 字符串不一样. 123456var s_prim = 'foo';var s_obj = new String(s_prim);console.log(typeof s_prim); // \"string\"console.log(typeof s_obj); // \"object\"console.log(s_prim === s_obj); // false 答案是 &#39;Do not know!&#39; 第10题12345678910111213141516function showCase2(value) &#123; switch(value) &#123; case 'A': console.log('Case A'); break; case 'B': console.log('Case B'); break; case undefined: console.log('undefined'); break; default: console.log('Do not know!'); &#125;&#125;showCase2(String('A')); 解释:String(x) does not create an object but does return a string, i.e. typeof String(1) === &quot;string&quot; 还是刚才的知识点, 只不过 String 不仅是个构造函数 直接调用返回一个字符串哦. 答案 &#39;Case A&#39; 第11题1234567891011function isOdd(num) &#123; return num % 2 == 1;&#125;function isEven(num) &#123; return num % 2 == 0;&#125;function isSane(num) &#123; return isEven(num) || isOdd(num);&#125;var values = [7, 4, '13', -9, Infinity];values.map(isSane); 一个知识点 Arithmetic_Operators#Remainder 此题等价于 123457 % 2 =&gt; 14 % 2 =&gt; 0'13' % 2 =&gt; 1-9 % % 2 =&gt; -1Infinity % 2 =&gt; NaN 需要注意的是 余数的正负号随第一个操作数. 答案 [true, true, true, false, false] 第12题123parseInt(3, 8)parseInt(3, 2)parseInt(3, 0) 第一个题讲过了, 答案 3, NaN, 3 第13题1Array.isArray( Array.prototype ) 一个知识点: Array/prototype 一个鲜为人知的实事: Array.prototype =&gt; []; 答案: true 第14题123456var a = [0];if ([0]) &#123; console.log(a == true);&#125; else &#123; console.log(\"wut\");&#125; JavaScript-Equality-Table 一图胜千言 答案: false 第15题1[]==[] == 是万恶之源, 看上图 答案是 false 第16题12'5' + 3'5' - 3 两个知识点: Arithmetic_Operators#Addition Arithmetic_Operators#Subtraction + 用来表示两个数的和或者字符串拼接, -表示两数之差. 请看例子, 体会区别: 12345678910&gt; '5' + 3'53'&gt; 5 + '3''53'&gt; 5 - '3'2&gt; '5' - 32&gt; '5' - '3'2 也就是说 - 会尽可能的将两个操作数变成数字, 而 + 如果两边不都是数字, 那么就是字符串拼接. 答案是 &#39;53&#39;, 2 第17题11 + - + + + - + 1 这里应该是(倒着看)123456781 + (a) =&gt; 2a = - (b) =&gt; 1b = + (c) =&gt; -1c = + (d) =&gt; -1d = + (e) =&gt; -1e = + (f) =&gt; -1f = - (g) =&gt; -1g = + 1 =&gt; 1 所以答案 2 第18题123var ary = Array(3);ary[0]=2ary.map(function(elem) &#123; return '1'; &#125;); 稀疏数组. 同第7题. 题目中的数组其实是一个长度为3, 但是没有内容的数组, array 上的操作会跳过这些未初始化的’坑’. 所以答案是 [&quot;1&quot;, undefined × 2] 第19题123456789function sidEffecting(ary) &#123; ary[0] = ary[2];&#125;function bar(a,b,c) &#123; c = 10 sidEffecting(arguments); return a + b + c;&#125;bar(1,1,1) 这是一个大坑, 尤其是涉及到 ES6语法的时候 知识点: Functions/arguments 首先 The arguments object is an Array-like object corresponding to the arguments passed to a function. 也就是说 arguments 是一个 object, c 就是 arguments[2], 所以对于 c 的修改就是对 arguments[2] 的修改. 所以答案是 21. 然而!!!!!! 当函数参数涉及到 any rest parameters, any default parameters or any destructured parameters 的时候, 这个 arguments 就不在是一个 mapped arguments object 了….. 请看: 123456789function sidEffecting(ary) &#123; ary[0] = ary[2];&#125;function bar(a,b,c=3) &#123; c = 10 sidEffecting(arguments); return a + b + c;&#125;bar(1,1,1) 答案是 12 !!!! 请读者细细体会!! 第20题1234var a = 111111111111111110000, b = 1111;a + b; 答案还是 111111111111111110000. 解释是 Lack of precision for numbers in JavaScript affects both small and big numbers. 但是笔者不是很明白……………. 请读者赐教! 第21题12var x = [].reverse;x(); 这个题有意思! 知识点: Array/reverse The reverse method transposes the elements of the calling array object in place, mutating the array, and returning a reference to the array. 也就是说 最后会返回这个调用者(this), 可是 x 执行的时候是上下文是全局. 那么最后返回的是 window. 答案是 window 第22题1Number.MIN_VALUE &gt; 0 true 今天先到这里, 下次我们来看后22个题!","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://xiaoyu2er.github.io/tags/Javascript/"}]},{"title":"Gulp 监听文件删除事件","date":"2016-03-30T16:00:00.000Z","path":"2016/03/31/gulp-watch-delete-files/","text":"Gulp是前端自动化的一个非常有用的工具, 如何使用Gulp甚至可以单开一个系列(一定会的!). 在使用Gulp的过程中, 有一个非常讨厌的问题, 就是监听文件删除事件. 设想这样一个场景, 我们在src/写ES6, 通过gulp-babel转化为ES5文件, 输出到build/下, 同时, 使用gulp-inject将build/下的js文件通过script标签的方式添加到index.html中; 增改文件都是极好的, 但是如果删除了src/下的某个文件, build/ 下的文件并不会自动删除, 所以index.html还是会引用. 怎么解决呢? Show Me the CODE! 12345678910111213141516gulp.task('watch', ['clean', 'build'], function () &#123; gulp.watch('src/index.html', ['inject']); var watcher = gulp.watch(['src/**/*', '!src/index.html'], ['babel', 'inject']); watcher.on('change', function (event) &#123; if (event.type === 'deleted') &#123; var src = path.relative(path.resolve('src'), event.path); src = src.replace(/.es6$/, '.js'); var dest = path.resolve(buildDir, src); del.sync(dest); &#125; &#125;);&#125;); 最关键的还是这个 var watcher = gulp.watch() 啦, watcher这个句柄就可以监听文件变动的事件了, 其中, event 就有type的属性, 用于表示是新增文件, 还是修改文件, 亦或是删除文件, 然后path属性表示当前变动的文件地址, 知道了这些信息, 就可以干任何事情啦! Gulps gulp.watch not triggered for new or deleted files? Handling the Delete Event on Watch","tags":[{"name":"Gulp","slug":"Gulp","permalink":"http://xiaoyu2er.github.io/tags/Gulp/"}]},{"title":"webpack 资料整理 (持续更新)","date":"2016-03-20T16:00:00.000Z","path":"2016/03/21/awesome-webpack/","text":"Webpack Fundamentals(视频系列教程) 如何使用 Webpack - webpack-howto (翻译)(Instagram) 配套视频, Instagram团队Peter-Hunt的分享 视频: Advanced Webpack (Lonely Planet的前端) 很多实用的技巧 Webpack 入门指迷 Webpack 性能优化 （一）(使用别名做重定向) 基于webpack搭建前端工程解决方案探索 (评论更精彩) webpack-seed (一个基于webpack搭建的工程例子 很有借鉴意义 可以做到同时支持SPA和多页面型的项目) 基于webpack搭建前端工程解决方案探索 【前端构建】WebPack实例与前端性能优化 gulp + webpack 构建多页面前端项目 请关注 xiaoyu2er/awesome-webpack","tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://xiaoyu2er.github.io/tags/Webpack/"},{"name":"前端工程化","slug":"前端工程化","permalink":"http://xiaoyu2er.github.io/tags/前端工程化/"}]},{"title":"Google 镜像站搜集(2016年7月23日更新)","date":"2016-03-15T16:00:00.000Z","path":"2016/03/16/google-mirror/","text":"自由的接触信息应该是每个人不可剥夺的基本人权. 持续更新! 敬请关注! google-mirror-check npm包已发布 如果您是以下镜像的作者, 且不希望出现在以下列表中，可以联系我移除链接。 http://gc.ihuan.me/ (1440ms) http://soguge.com/ (1476ms) http://s.8090st.com/ (1816ms) https://g.jikewenku.cn/ (2338ms) http://www.bjgong.tk/ (2964ms) https://g.alexyang.me/ (3293ms) https://g.libnull.com/ (3681ms) https://g.zrj766.com/ (3861ms) https://ggss.cf/ (4127ms) https://ggso.in/ (4500ms) https://www.onenew.net/ (4861ms) http://hao.cytbj.com/ (5395ms) http://www.zzq2.com/ (5428ms) http://ggss.cf/ (5947ms)","tags":[{"name":"Tools","slug":"Tools","permalink":"http://xiaoyu2er.github.io/tags/Tools/"},{"name":"Google","slug":"Google","permalink":"http://xiaoyu2er.github.io/tags/Google/"}]},{"title":"设置 Mac 下文件的默认打开程序 — duti 详解","date":"2016-01-30T16:00:00.000Z","path":"2016/01/31/mac-default-app-for-spec-file-type/","text":"在 mac 中打开一个文件会有一个默认的应用. 但是这个应用往往不是我们希望的那个. 比如我想打开一个 .c, Mac 会启动 XCode来打开这个文件, 这往往不是我希望的.再比如我想打开一个 .md 文件, 这货居然没有默认打开方式, 这个时候我们可能会右击然后找到那个打开方式, 设置成为 sublime 或者 mou. 但是碰到一个 .markdown的文件, 系统又蒙圈了, 还是不知道用什么打开, 当然我们也可以按照刚才说的去修改. 那么有没有一个快捷的方式, 可以批量的修改系统中所有文件的默认打开方式呢? 有! 就是我们今天要介绍的 duti Conceptsduti是 Mac 下的一个命令行工具, 主要作用为不同文件类型设置默认的应用. duti 的意思其实就是 default for UTI 在介绍如何使用之前我们需要明确几个概念: UTIMac 下的文件类型被定义为 Uniform Type Identifiers (UTI). 例如, HTML 文件的 UTI 是 public.html; Word 文档的 UTI 是 com.microsoft.word.doc.那么改变文件类型的默认打开方式的第一步就是确认文件类型啦. 第一个方式是去看苹果列出来的 UTI Uniform Type Identifiers Reference 第二个方式是使用 mdls 命令, 这哥们的作用就是: lists the metadata attributes for the specified file那么如何使用呢, 很简单只要把你想要获得 UTI 的文件作为参数就好了 12345678910$ mdls test.txtkMDItemContentType = \"public.plain-text\"kMDItemContentTypeTree = ( \"public.plain-text\", \"public.text\", \"public.data\", \"public.item\", \"public.content\") 我们可以看到其中就有这样的输出(截取). 可以看到一个 .txt 文件的 UTI 就是 public.plain-text, 那么下面这一坨是干什么的呢?因为文件类型也有一个具体和宽泛的划分嘛, 越往下约 general.再来看一个 12345678910$ mdls test.csskMDItemContentType = \"public.css\"kMDItemContentTypeTree = ( \"public.css\", \"public.text\", \"public.data\", \"public.item\", \"public.content\") public.css 就是 .css 的 UTI. Bundle IDBundle ID (应用标识符)) 是 iOS 或者 Mac 应用的唯一标识. 也就是我们希望用什么软件打开我们的文件的那个软件的 ID 啦. 可以用以下命令获得 Bundle ID: 12345678$ osascript -e 'id of app \"Finder\"'com.apple.finder$ osascript -e 'id of app \"Atom\"'com.github.atom$ osascript -e 'id of app \"Sublime Text 2\"'com.sublimetext.2 Bundle Id &amp; UTI那么知道了文件的类型UTI, 知道了软件的 Bundle ID, 距离设定文件的默认程序其实就差一步了.还有一个概念, 就是这个软件对于这个文件是个什么角色. 其实我们这里大部分情况只需要关心 editor 这个角色. 就是编辑角色. 其他的没啥用. all: application handles all roles for the given UTI. viewer: application handles reading and displaying documents with the given UTI. editor: application can manipulate and save the item. Implies viewer. shell: application can execute the item. none: application cannot open the item, but provides an icon for the given UTI. Usage好了, 介绍了这么多概念, 终于到了修改文件默认打开方式的时候了! 1duti [ -hVv ] [ settings_path ] 如果上述语句没有给settings_path, duti 将会从标准输入读取配置. 如果setting_path是个文件夹的话, 那么 duti 将会从文件夹内的所有文件中读取配置. 那么这个 setting_path 文件的每一行其实需要三个字段: 应用的标识符 Bundle ID (比如: com.apple.Safari) 文件类型的 UTI (比如: public.html), 扩展名或者 MIME 类型 应用对于 UTI 的角色是什么 (比如, editor 编辑器) options -s: 选项会让 duti 从命令行读参数. -x ext: 选项会让 duti 输出参数中扩展名对应的默认应用 -d uti: 打印 UTI 的默认应用. -l uti: 打印 UTI 的所有可用应用. -V: 打印版本. -v: 详细输出. -h: 帮助. examples使用 -s 选项, 从命令行读取参数: 12duti -s com.apple.Safari public.html allduti -s com.apple.Finder ftp 但是我比较喜欢把这个设定放到一个文件里, 比如 duti-sublime,我希望用 Sublime 打开 .md, .css, .js, 以及富文本文件, 纯文本文件, 以及一些 shell 脚本.那么我的文件内容如下: 1234567com.sublimetext.2 net.daringfireball.markdown editorcom.sublimetext.2 public.css editorcom.sublimetext.2 public.script editorcom.sublimetext.2 public.source-code editorcom.sublimetext.2 public.rtf editorcom.sublimetext.2 public.plain-text editorcom.sublimetext.2 public.unix-executable editor 运行命令: 1duti duti-sublime 然后我们在使用 -x 选项, 打印 UTI 的默认应用 1234$ duti -x cssSublime Text 2.app/opt/homebrew-cask/Caskroom/sublime-text/2.0.2/Sublime Text 2.appcom.sublimetext.2 双击test.css就是Sublime打开啦~ Reference https://developer.apple.com/library/mac/documentation/Miscellaneous/Reference/UTIRef/Articles/System-DeclaredUniformTypeIdentifiers.html http://superuser.com/questions/209145/how-to-get-a-files-uti-from-the-command-line-in-mac-os-x","tags":[{"name":"Tools","slug":"Tools","permalink":"http://xiaoyu2er.github.io/tags/Tools/"},{"name":"Mac","slug":"Mac","permalink":"http://xiaoyu2er.github.io/tags/Mac/"}]},{"title":"SVG (一) 基础知识总结","date":"2016-01-29T16:00:00.000Z","path":"2016/01/30/svg-1-basics/","text":"table:nth-of-type(2) td:nth-of-type(1) { width:30%; } img { width: 80%; } 近期工作中要处理很多 SVG 图片, 所以从零开始学习了 SVG 的相关内容.我看的是这本书 SVG Essentials, 2nd Edition,以及它的中译版 SVG精髓（第2版）.这本书深入浅出, 例子很多, 非常不错. 因为 svg 涉及到很多关于颜色的内容, 所以还是建议大家看电子版. 工作中的任务是实现一个相框功能, 当中涉及到了诸如 use, image, clip-path 的内容, 学习了一段时间后总算解决了, 所以希望记录一下学习内容和解决方案.内容比较多, 所以准备开一个系列, 这是 SVG 系列的第一篇, 基础知识总结. 后续将会有更多关于 SVG 的内容. 敬请期待! SVG basicsShape Reference Summary 形状 描述 &lt;line x1=&quot;start-x&quot; y1=&quot;start-y&quot; x2=&quot;end-x&quot; y2=&quot;end-y&quot;/&gt; 直线: 起点(start-x, start-y) 终点(end-x, end-y); &lt;rect x=&quot;left-x&quot; y=&quot;top-y&quot; width=&quot;width&quot; height=&quot;height&quot; /&gt; 矩形: 左上角(left-x, top-y), 宽高 width, height &lt;circle cx=&quot;center-x&quot; cy=&quot;center-y&quot; r=&quot;radius&quot;/&gt; 圆: 圆心(center-x, center-y) 半径 r &lt;ellipse cx=&quot;center-x&quot; cy=&quot;center-y&quot; rx=&quot;x-radius&quot; ry=&quot;y-radius&quot;/&gt; 椭圆: 圆心(center-x, center-y) xy轴半径 rx, ry &lt;polygon points=&quot;points-list&quot;/&gt; 多边形: 由一系列坐标组成, points-list: x1 y1 x2 y2 x3 y3 …. &lt;polyline points=&quot;points-list&quot;/&gt; 折线: 由一系列坐标组成, points-list: x1 y1 x2 y2 x3 y3 …. Path Reference Summary本质上, 上述基本形状都是路径(path)的简写. 简写可以使得 svg 文档更具有可读性. 但是当碰到复杂路径时, 就需要 path 来描述. 以下总结中, 凡是出现大写字母表示后续坐标为绝对坐标, 凡是小写字母都代表相对于上一个坐标的相对位移. Z 同 z 无差别. 因为表示闭合, 其后不用跟坐标 command 描述 M(m) x y 移动到(x, y) (小写表示相对于上个坐标的位移, 下同) L(l) x y 画一条直线到(x, y) H(h) x 水平画一条直线到 x V(v) y 竖直画一条直线到 y A(a) rx ry x-axis-rotation large-arc sweep x y 画一段到(x,y)的椭圆弧. 椭圆弧的 x, y 轴半径分别为 rx,ry. 椭圆相对于 x 轴旋转 x-axis-rotation 度. large-arc=0表明弧线小于180读, large-arc=1表示弧线大于180度. sweep=0表明弧线逆时针旋转, sweep=1表明弧线顺时间旋转. 具体解释看如何绘制椭圆弧 Q(q) cx cy x y 从当前点画一条到(x, y)的二次贝塞尔曲线, 曲线的控制点为(cx, cy). 关于二次贝塞尔曲线请看二次贝塞尔曲线详解 T(t) x y 此命令只能跟在一个 Q 命令使用, 假设 Q 命令生成曲线 s, T 命令的作用是从 s 的终点再画一条到(x y)的二次贝塞尔曲线, 曲线的控制点为 s 控制点关于 s 终点的对称点. T 命令生成的曲线会非常平滑 C(c) cx1 cy1 cx2 cy2 x y 从当前点画一条到(x, y)的三次贝塞尔曲线, 曲线的开始控制点和终点控制点为别为 (cx1, cy1), (cx2, cy2). 关于三次贝塞尔曲线请看三次贝塞尔曲线详解 S(s) cx2 cy2 x y 此命令只能跟在 C 命令后使用, 假设 C 命令生成曲线 s, S 命令的作用是再画一条到 (x, y)的三次贝塞尔曲线, 曲线的终点控制点是 (cx2, cy2), 曲线的开始控制点是 s 的终点控制点关于 s 终点的对称点. Transformation Reference Summary transform 描述 translate(x, y) 平移: 将用户坐标系统的坐标原点移动到(x, y) scale(xFactor, yFactor) 缩放: 将用户坐标系统的xy轴单位长度分别乘(xFactor, yFactor)倍 scale(factor) 缩放: 同 scale(factor, factor) rotate(angle, centerX, centerY) 旋转: 将用户坐标系统以(centerX, centerY)为旋转中心顺时针旋转 angle 度 rotate(angle) 旋转: 同 rotate(angle, 0, 0) skewX(angle) 倾斜: 根据 angle 倾斜所有 x 轴坐标, 视觉上会看到 y 轴倾斜… skewY(angle) 倾斜: 根据 angle 倾斜所有 y 轴坐标, 视觉上会看到 x 轴倾斜… matrix(a b c d e f) 矩阵变换: 将坐标系统进行矩阵变换, 详细内容请参考后续文章 DetailsEllipse一种直观的表示椭圆弧线的方式是, 根据椭圆中心 (x, y), x 轴半径 rx, y 轴半径 ry, 开始角度 startAngle, 结束角度 endAngle.但是为什么 SVG 会采用 A(a) rx ry x-axis-rotation large-arc sweep x y 这样的形式呢,主要是因为在 SVG 中, 弧线并不是孤立的存在, 他要成为整体的一部分. 所以 SVG 采用了起始点这样的方式.那么其他的 x-axis-rotation, large-arc, sweep 又是什么意思呢? 我们现在来看下面这张图. 当确定了两个点已经椭圆的 rx, ry 后并不能唯一确定一条椭圆弧, 实际上根据是否是大圆, 路径是否是逆时针可以产生四条 (b, c, d, e)其中, large-arc-flag=0 表示小圆, sweep-flag=0 表示逆时针. 那么 x-axis-rotation 又是什么意思呢? b, c, d, e 产生的前提是 椭圆的 x 轴与用户坐标系的 x 轴是平行的.f 图表示椭圆 x 轴相对于用户坐标系的 x 轴旋转30度所产生的椭圆弧. 灰色的部分表示原来产生的椭圆弧. Quadratic Bezier关于贝塞尔曲线的数学含义请看Bézier curve这里直观的讲一下 以上曲线的路径表示是: &lt;path d=&quot;M200,300 Q400,50 600,300 T1000,300&quot;/&gt;我们可以看出:A 是起点, B 是终点, C 就是控制点.找出 AC 的重点 D, BC 的重点 E, 连接 DE, 找出其中点 F, F 即这条曲线前半段的一个切点. 这里不谈数学含义, 这样的几何意义更加直观. 再来看 T 命令, 其实 T 命令是 Q 的一个简写.其控制点 H 就是上个 Q 命令的控制点 C 关于终点 B 的对称点.使用 T 命令产生的曲线往往比较顺滑 :) Cubic Bezier再来看一下三次贝塞尔曲线 &lt;path d=&quot;M100,200 C100,100 250,100 250,200 S400,300 400,200&quot;/&gt; 前半段曲线(C 命令) s1:起点 A, 终点 B, 起点控制点 C, 终点控制点 D, 连接 AC, BD, CD;找到 CD 中点 F, 连接 AC 中点 E 与 F, 连接 BD 中点 G 与 F;连接 EF, FG, 连接 EF 中点 H 与 FG 中点 I;I 即为前半段曲线的切点; 后半段曲线(S 命令) s2:S 只能跟在 C 命令后使用;s2 的起点 B, 终点 L, 终点控制点 K;s2 的起点控制点是 s1 的终点控制点 D 关于 s1终点 B 的对称点 下图是更多关于三次贝塞尔曲线的例子: Reference SVG Essentials, 2nd Edition SVG精髓（第2版） 以上图片均改编自W3C SVG规范 MDN SVG Tutorial - Path","tags":[{"name":"SVG","slug":"SVG","permalink":"http://xiaoyu2er.github.io/tags/SVG/"}]},{"title":"深入理解 Angular Scope 的继承关系","date":"2016-01-22T16:00:00.000Z","path":"2016/01/23/angular-scope-in-depth/","text":"JavaScript Prototypal Inheritance首先我们先来回顾以下 javascript 中出现的原型继承: 12345678910111213141516171819function ParentScope()&#123; this.aString = \"parent string\"; this.aNumber = 100; this.anArray = [10,20,30]; this.anObject = &#123; 'property1': 'parent prop1', 'property2': 'parent prop2' &#125;; this.aFunction = function()&#123; return 'parent output'; &#125;&#125;function ChildScope()&#123;&#125;ChildScope.prototype = new ParentScope();var childScope = new ChildScope(); ChildScope 原型继承自 ParentScope 如果我们要在 childScope 上查询一个定义在 parentScope 的属性, JavaScript 会先在 childScope 上查找, 如果没有查到, 那么会顺着原型链去查找. 所以以下判别式均为 true 1234childScope.aString === 'parent string'childScope.anArray[1] === 20childScope.anObject.property1 === 'parent prop1'childScope.aFunction() === 'parent output' 如果我们做如下操作: 1childScope.aString = 'child string' 原型链并没有被访问, 一个新的 aString 会被加入到 childScope 的属性中去, 新的属性会隐藏 parentScope 中的同名属性. 假设我们做出如下操作: 12childScope.anArray[1] = 22childScope.anObject.property1 = 'child prop1' 原型链被访问了. 因为 anArray, anObject 没有在 childScope 中找到.新的赋值操作均在 parentScope 上进行. childScope 上没有添加任何新的属性. 如果我们做出如下操作 12childScope.anArray = [100, 555]childScope.anObject = &#123; name: 'Mark', country: 'USA' &#125; 原型链没有被访问, childScope 会获得两个新的属性, 并且会隐藏 parentScope 上的同名属性. 仔细体会上面的三次操作. 第一第三次均是对某个属性进行赋值, 原型链并不会被访问, 由于属性并不存在, 所以新的属性将会被添加. 而第二次其实是先访问, childScope.anArray, childScope.anObject, 再对其访问的对象的某个属性进行复制. 总结: 如果我们读取 childScope.propertyX, 而 childScope 拥有 propertyX, 那么原型链不会被访问 如果我们读取 childScope.propertyX, 而 childScope 并没有 propertyX, 那么原型链会被访问. 如果对 childScope.propertyX 进行赋值, 那么原型链并不会被访问. 最后我们再来看一种情况: 12delete childScope.anArraychildScope.anArray[1] === 22 // true 我们显示删除了 childScope 的一个属性, 接着试图读取这个属性, 由于 childScope 并没有了这个属性, 所以原型链会被访问. Angular Scope Inheritance接着我们来看看 Angular 中的 scope 继承 以下指令会创建新的 scope, 并且会在原型上继承 父scope (即$scope.$parent, 下文两个词互为同义词): ng-repeat ng-switch ng-view ng-controller 带有 scope: true 的指令 带有 transclude: true 的指令 以下指令创建新的指令, 且在原型上 不继承 父scope: 带有 scope: { ... } 的指令, 这会创建一个 独立的scope (isolate scope) 注意: 默认指令并不会创建 scope, 默认是 scope: false, 通常称之为 共享scope. 让我们来看几个例子: ng-includeJS: 12$scope.myPrimitive = 50;$scope.myObject = &#123;aNumber: 11&#125;; HTML: 123456789101112&lt;p&gt;&#123; myPrimitive &#125;&lt;/p&gt;&lt;p&gt;&#123; myObject.aNumber &#125;&lt;/p&gt; // cannot use double curly brackets in jekyll&lt;script type=\"text/ng-template\" id=\"/tpl1.html\"&gt; &lt;input type=\"number\" ng-model=\"myPrimitive\"&gt;&lt;/script&gt;&lt;div ng-include src=\"'/tpl1.html'\"&gt;&lt;/div&gt;&lt;script type=\"text/ng-template\" id=\"/tpl2.html\"&gt; &lt;input type=\"number\" ng-model=\"myObject.aNumber\"&gt;&lt;/script&gt;&lt;div ng-include src=\"'/tpl2.html'\"&gt;&lt;/div&gt; 每一个 ng-include 都会创建一个 子scope, 并在原型上继承 父 scope 向第一个 input 输入数字, 一个新的属性 myPrimitive 将会被创建, 同时隐藏 父 scope 的 myPrimitive; 向第二个 input 输入数字, 子 scope 并不会创建一个新的属性, 这时候原型继承发挥了作用. 第一种情况很可能不是我们期待的结果, 所以可以显式的调用 $parent 来解决这个问题. 1&lt;input ng-model=\"$parent.myPrimitive\"&gt; 向第一个 input 键入数字, 这时候就不会产生新的属性了. $parent 指向了 父scope. 但是 $parent 和 原型上的继承并不一定相等. 稍后我们会看到一个例子. 对于所有的 scope, 无论是共享的(scope: false), 继承的(scope: true), 还是孤立的(scope: { ... }), Angular 都会建立一个 父-子 的层级关系, 这个层级关系是根据 dom 结构的层级关系决定的, 可以通过 $parent, $$childHead, $$childTail 来访问. 为了避免刚才的例子出现的子 scope 创建新属性情况的发声, 除了使用 $scope, 还可以使用调用原型链上的方法. 1234// in the parent scope$scope.setMyPrimitive = function(value) &#123; $scope.myPrimitive = value;&#125; ng-switch ng-viewng-switch, ng-view 与 ng-include 情况类似, 不赘述. ng-repeatng-repeat 有一点特殊. JS: 12$scope.myArrayOfPrimitives = [ 11, 22 ];$scope.myArrayOfObjects = [&#123;num: 101&#125;, &#123;num: 202&#125;] HTML: 12345678&lt;ul&gt;&lt;li ng-repeat=\"num in myArrayOfPrimitives\"&gt; &lt;input ng-model=\"num\"&gt;&lt;/input&gt; &lt;/li&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li ng-repeat=\"obj in myArrayOfObjects\"&gt; &lt;input ng-model=\"obj.num\"&gt;&lt;/input&gt; &lt;/li&gt;&lt;/ul&gt; 对于每一次迭代, ng-repeat 都会创建一个 子scope, 并在原型上继承 父scope, 但是他还会将 父scope 上的属性赋值到 子scope 上. 新的属性名就是 ng-repeat=&quot;** in parentScope.property&quot; 中的 **.源码中的 ng-repeat 是这样的: 12childScope = scope.$new(); // child scope prototypically inherits from parent scope ...childScope[valueIdent] = value; // creates a new childScope property 如果 ** 是 primitive, 那么一份 copy 会被赋值到新的属性上. 修改 子scope 上的新属性自然不会修改 父 scope 上的属性. 如果 ** 是个 object, 那么一个 reference 会被赋值到新的 子scope 属性上. 修改这个属性, 就是修改 父scope 对应的属性. ng-controllerng-controller 也是会创建新的 子scope, 同时原型继承 父scope. 如同 ng-include, ng-switch, ng-view.但是, 使用 $scope 来共享数据被认为是一种不好的操作. 因为原型链可是会一直向上追溯的.如果想要共享数据, 最好使用 service. Angular Directives我们来总结以下指令中的 scope: scope: false(默认的), 指令不会创建新的 scope, 没有继承关系. 与 $parent 共享 $scope. scope: true, 指令会创建一个 子scope, 并在原型上继承 $parent. 如果在一个 DOM 上有多个指令想要创建新的 scope, 会报错. scope: { ... }, 指令会创建一个 孤立的scope. 这在创建可重用的组件时是最好的选择. 但是, 即使如此, 指令还是希望读取 $parent 的数据. 这个时候可以使用如下符号获得: scope: { **: &quot;=&quot;} 与 $parent 建立双向绑定. scope: { **: &quot;@&quot;} 与 $parent 建立单向绑定. scope: { **: &quot;&amp;&quot;} 绑定 $parent 的表达式.想要获得相应的属性, 必须通过指令上的属性获得 HTML: &lt;div my-directive the-Parent-Prop=parentProp&gt; JS: scope: { localProp: &#39;@theParentProp&#39; }假设: HTML: &lt;my-directive interpolated=&quot;&quot; twowayBinding=&quot;parentProp2&quot;&gt; JS: scope: { interpolatedProp: &#39;@interpolated&#39;, twowayBindingProp: &#39;=twowayBinding&#39; } 指令在 link 期间: scope.someIsolateProp = &quot;I&#39;m isolated&quot;其中的关系如图: transclude: true, 指令创建了一个 “transcluded” 的子scope, 在原型上继承其 父scope. 如果上述例子同时具有transclude: true. 那么这个 “transcluded” scope, 和 “islolated” scope 是姊妹关系. 他们的 $parent 指向同一个 scope. 且 isolate scope 的 $$nextSibling 就是这个 “transcluded scope”. 下图反应了他们之间的关系: Reference Angular Wiki: Understanding Scopes","tags":[{"name":"Angular","slug":"Angular","permalink":"http://xiaoyu2er.github.io/tags/Angular/"}]},{"title":"Angular $q 完全指南","date":"2016-01-07T16:00:00.000Z","path":"2016/01/08/angular-q-complete-guide/","text":"Angular $q 完全指南如果想使用 $http 或者其他异步操作, 那 $q 是必须要掌握的概念啦. Let’s get started! 如何理解$q, deferred object ?形象的讲解angular中的$q与promise 假设有一个家具厂，而它有一个VIP客户张先生。 有一天张先生需要一个豪华衣柜，于是，他打电话给家具厂说我需要一个衣柜，回头做好了给我送来，这个操作就叫$q.defer，也就是延期，因为这个衣柜不是现在要的，所以张先生这是在发起一个可延期的请求。 同时，家具厂给他留下了一个回执号，并对他说：我们做好了会给您送过去，放心吧。这叫做promise，也就是承诺。 这样，这个defer算是正式创建了，于是他把这件事记录在自己的日记上，并且同时记录了回执号，这叫做deferred，也就是已延期事件。 现在，张先生就不用再去想着这件事了，该做什么做什么，这就是“异步”的含义。 假设家具厂在一周后做完了这个衣柜，并如约送到了张先生家（包邮哦，亲），这就叫做deferred.resolve(衣柜)，也就是“已解决”。而这时候张先生只要签收一下这个（衣柜）参数就行了，当然，这个“邮包”中也不一定只有衣柜，还可以包含别的东西，比如厂家宣传资料、产品名录等。整个过程中轻松愉快，谁也没等谁，没有浪费任何时间。 假设家具厂在评估后发现这个规格的衣柜我们做不了，那么它就需要deferred.reject(理由)，也就是“拒绝”。拒绝没有时间限制，可以发生在给出承诺之后的任何时候，甚至可能发生在快做完的时候。而且拒绝时候的参数也不仅仅限于理由，还可以包含一个道歉信，违约金之类的，总之，你想给他什么就给他什么，如果你觉得不会惹恼客户，那么不给也没关系。 假设家具厂发现，自己正好有一个符合张先生要求的存货，它就可以用$q.when(现有衣柜)来把这个承诺给张先生，这件事就立即被解决了，皆大欢喜，张先生可不在乎你是从头做的还是现有的成品，只会惊叹于你们的效率之高。 假设这个家具厂对客户格外的细心，它还可能通过deferred.notify(进展情况)给张先生发送进展情况的“通知”。 这样，整个异步流程就圆满完成，无论成功或者失败，张先生都没有往里面投入任何额外的时间成本。 好，我们再扩展一下这个故事： 张先生这次需要做一个桌子，三把椅子，一张席梦思，但是他不希望今天收到个桌子，明天收到个椅子，后天又得签收一次席梦思，而是希望家具厂做好了之后一次性送过来，但是他下单的时候又是分别下单的，那么他就可以重新跟家具厂要一个包含上述三个承诺的新承诺，这就是$q.all(桌子承诺，椅子承诺，席梦思承诺)， 这样，他就不用再关注以前的三个承诺了，直接等待这个新的承诺完成，到时候只要一次性签收了前面的这些承诺就行了。 如何创建 promise -1$q 支持两种写法, 第一种是类似于ES6标准构造函数写法 $q(function resolver (resolve, reject) {}) 注意: + ES6 写法并不支持 progress/notify 的回调函数 + 在构造函数中抛异常也并不会显式的reject the promise 1234567891011121314// var iWantResolve = false;var iWantResolve = true;function es6promise() &#123; return $q(function (resolve, reject) &#123; $timeout(function () &#123; if (iWantResolve) &#123; resolve(\"es6promise resolved\"); &#125; else &#123; reject(\"es6promise reject\"); &#125; &#125;, 1000) &#125;)&#125; promise 的方法 promise.then(successCb, errCb, notifyCb) 其中successCb 将在 promise resolve 后被调用, errCb 将在 promise reject 后被调 notifyCb 将在 deferred.notify 后被调用, 可以多次调用 promise.catch == promise.then(null, errCb), 用于处理之前没有被处理的 rejected promise promise.finally 将最后被调用, 一般用于资源释放的清理操作 12345678910es6promise() .then(function (data) &#123; console.log(data); &#125;) .catch(function (err) &#123; console.log(err); &#125;);// if(iWantResolve == true) output: es6promise resolved// if(iWantResolve = false) output: es6promise reject 如何创建 promise -2第二种是类似于 commonJS 的写法 $q.deferred() 123456789101112131415161718192021222324252627function commonJsPromise() &#123; var deferred = $q.defer(); $timeout(function () &#123; deferred.notify(\"commonJS notify\"); if (iWantResolve) &#123; deferred.resolve(\"commonJS resolved\"); &#125; else &#123; deferred.reject(\"commonJS reject\"); &#125; &#125;, 500); return deferred.promise;&#125;commonJsPromise() .then(function /** success callback**/(data) &#123; console.log(data); &#125;, function /** error callback **/ (err) &#123; console.log(err); &#125;, function /** progress callback **/ (update) &#123; console.log(update); &#125;);// if(iWantResolve == true) output: commonJS notify commonJS resolved// if(iWantResolve = false) output: commonJS notify commonJS reject $q.all $q.all([promise1, promise1]) 接受一个包含若干个 promise 的数组, 等所有的 promise resolve 后, 其本身 resolve 包含上述结果的数组 [data1, data2] 如果上述 promise 有一个 reject, 那么$q.all() 会把这个 rejected promise 作为其 rejected promise (只有一个哦) progress/notify 的 callback 并没有用 12345678910$q.all([es6promise(), commonJsPromise()]) .then(function (dataArr) &#123; console.log(\"$q.all: \", dataArr); &#125;, function (err) &#123; console.log(\"$q.all: \", err) &#125;, function /** unnecessary **/ (update) &#123; console.log(\"$q.all\", update); &#125;);// if(iWantResolve == true) output: $q.all: [\"es6promise resolved\", \"commonJS resolved\"]// if(iWantResolve = false) output: $q.all: es6promise reject $q.reject, $q.when, $q.resolve $q.reject() 立即返回一个rejected 的 promise, 在链式调用的时候很有用 $q.resolve == $q.when(value, successCb, errorCb, progressCb) value 可能是一个 then-able 的 obj(即可以是 $q.defer() 返回的, 也可以是其他库产生的), 也可能是任意数据, 但是 $q.when 最终都会返回一个 promise $q.when 既可以写成上述的构造函数形式, 也可以写成 $q.when(value).then(fn, fn, fn) 的形式 12345678910111213141516171819202122232425262728$q.reject(\"instant reject\") .catch(function (err) &#123; console.log(err); &#125;);// output: instant reject$q.when(commonJsPromise(), function /** success callback **/(data) &#123; console.log(\"$q.when success callback function: \" + data); return \"$q.when success callback return another value\"; &#125;) .then(function (data) &#123; console.log(\"$q.when then function:\" + data); &#125;);// if(iWantResolve == true) output:// $q.when success callback functionL: commonJS resolved// $q.when then function:$q.when success callback return another value// if(iWantResolve = false) output:// $q.when err callback function: commonJS reject// $q.when then function:undefined$q.when(\"some value\", function (data)&#123; console.log(data);&#125;)// output: some value promise chains 链式调用任何在 successCb, errCb 中返回的非 $q.reject()对象, 都将成为一个 resolve 的 promise.所以可以出现如下语法promise.then().then().then() 1234567891011121314$q.when(\"1\") .then(function (data) &#123; console.log(data); return $q.reject(2); &#125;) .catch(function (err) &#123; console.log(err); return 3; &#125;) .then(function (data) &#123; console.log(data); &#125;)// output: 1 2 3 参考资料 AngularJS Documentation for $q 形象的讲解angular中的$q与promise Angular Promise Chaining Explained $q.when() Is The Missing $q.resolve() Method In AngularJS How does Angular $q.when work? $q.when(promise) calls resolve() instead of reject()","tags":[{"name":"Angular","slug":"Angular","permalink":"http://xiaoyu2er.github.io/tags/Angular/"}]}]